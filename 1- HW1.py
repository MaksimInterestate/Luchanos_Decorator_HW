'''
    Написать простую функцию, которая на вход принимает строку ('test') и целое число (3),
а возвращает строку вида 'testTESTtest' - исходную строку, умноженную на 3, в разном регистре.
    Записать эту функцию в произвольную переменную. Напечатать эту переменную на экран. Что вы видите?
    Вызвать функцию суммирования через переменную, в которую вы только что её записали.
'''


def easy_func(msg: str, numb: int):
    new_str = ''
    for i in range(numb):
        if i % 2 != 0:
            new_str += msg.upper()
        else:
            new_str += msg.lower()
    return new_str


a = easy_func('test', 18)
print(a)

'''
Medium
1.    Написать функцию, которая на вход будет принимать произвольное количество аргументов и возвращать их сумму.
2.    В сигнатуре функции объявить 4 обязательных аргумента, но оставить возможность передавать 
в неё сколько угодно дополнительных аргументов. Попробуйте вызвать функцию в следующих ситуациях и объясните результат:
    прокинуть в функцию только 1 аргумент
    прокинуть аргументы таким образом, чтобы обязательный аргумент был передан одновременно позиционно и по ключу
    создать кортеж со значениями и распаковать его при вызове функции с помощью *
    создать словарь со значениями и распаковать его при вызове функции с помощью * и **: что наблюдаете? Почему?
'''


def medium_func(num1, num2, num3, num4, *args, **kwargs):
    return num1 + num2 + num3 + num4 + sum(args) + sum(kwargs.values())


# прокинуть в функцию только 1 аргумент
# a = medium_func(1)
# print(a) # TypeError medium_func() missing 3 required positional arguments: 'num2', 'num3', and 'num4'
# фнукция medium_func должна получать 4 позиционных аргумента, а получила только один, из=-за этого ошибка

# прокинуть аргументы таким образом, чтобы обязательный аргумент был передан одновременно позиционно и по ключу
print(medium_func(1, 2, num3=3, num4=4))  # 10

# создать кортеж со значениями и распаковать его при вызове функции с помощью *
tuple_for_func = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
print(medium_func(*tuple_for_func))  # 55

# создать словарь со значениями и распаковать его при вызове функции с помощью * и **: что наблюдаете? Почему?
dict_for_func = {
    'num1': 1,
    'num2': 2,
    'num3': 3,
    'num4': 4,
    'num5': 5,
    'num6': 6,
    'num7': 7,
    'num8': 8,
    'num9': 9,
    'num10': 10
}

dict_for_func2 = {
    10: 1,
    20: 2,
    30: 3,
    40: 4,
    50: 5
}

# a = medium_func( *dict_for_func)
# print(a)  # не может распаковать, тк в качестве слагаемых принмает ключ словаря


a = medium_func(*dict_for_func2)
print(a)  # 150 , а этот словарь распаковывает и складывает его ключи

a = medium_func(**dict_for_func)
print(a)  # 10 + оставшиеся значения ключей в словаре = 55

'''
Hard
    Модифицировать функцию таким образом, чтобы для суммирования брались только 
обязательные аргументы, первые 2 аргумента из дополнительных позиционных аргументов 
и любой аргумент из дополнительных аргументов (если они есть), переданных по ключу (если они есть).
'''


def hard_sum(num12, num22, num32, num42, *args, key_for_func=False, **kwargs):
    print('hard_sum')
    list_for_func = list(args)
    sum_list_for_func = list_for_func[0] + list_for_func[1]
    if key_for_func in kwargs.keys():
        numb_kwargs = kwargs[key_for_func]
        return f'num1 + num2 + num3 + num4 + сумма 2 аргументов из позиционных аргументов + аргумент,переданный по ключу = {num12}+{num22}+{num32}+{num42}+{sum_list_for_func}+{numb_kwargs} ' \
               f'\nsum ={num12+num22+num32+num42+sum_list_for_func+ numb_kwargs}'
    else:
        return f'num1 + num2 + num3 + num4 + сумма 2 аргументов из позиционных аргументов = {num12}+{num22}+{num32}+{num42}+{sum_list_for_func} ' \
               f'\nsum ={num12+num22+num32+num42+sum_list_for_func} '


print(hard_sum(1, 2, 3, 4, key_for_func='num110', *tuple_for_func, **dict_for_func))
